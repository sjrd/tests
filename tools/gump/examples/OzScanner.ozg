%%%  Programming Systems Lab,
%%%  Stuhlsatzenhausweg 3, D-66123 Saarbruecken, Phone (+49) 681 302-5609
%%%  Author: Leif Kornstaedt <kornstae@ps.uni-sb.de>

local
   OZVERSION = '2.1.0'   %--** take this from Oz/include/config.m4 instead

   Windows = ({System.get platform}.1 == win32)

   %--------------------------------------------------------------------
   % Scanner Auxiliary Functions
   %--------------------------------------------------------------------

   %--------------------------------------------------------------------
   % File Name Handling

   local
      PathSeparator = case Windows then &; else &: end

      fun {IsAbsoluteFileName S}
	 case S of &/|_ then true
	 elseof _|&:|_ then Windows   % good old DOS filename like E:...
	 else false
	 end
      end

      ozc(getUserHome: GetUserHome isReadableFile: IsReadableFile) =
      {Foreign.require 'ozc.o' ozc(getUserHome: 2 isReadableFile: 2)}

      fun {CheckAccess FileName}
	 case {IsReadableFile FileName} then FileName
	 else FileName2 = {Append FileName ".oz"} in
	    case {IsReadableFile FileName2} then FileName2
	    else ""
	    end
	 end
      end

      fun {GetDirName FileName}
	 {Reverse {List.dropWhile {Reverse FileName} fun {$ C} C \= &/ end}}
      end

      fun {SearchPath Path FileName}
	 case Path of _|_ then P1 Pr in
	    {List.takeDropWhile Path fun {$ C} C \= PathSeparator end ?P1 ?Pr}
	    case {CheckAccess {Append P1 &/|FileName}} of Res=_|_ then Res
	    elsecase Pr of !PathSeparator|Prr then {SearchPath Prr FileName}
	    [] nil then ""
	    end
	 [] nil then {CheckAccess &.|&/|FileName}
	 end
      end
   in
      fun {ExpandFileName FileName CurrentFileName}
	 case {IsAbsoluteFileName FileName} then {CheckAccess FileName}
	 elsecase FileName of &~|Sr then FileRest UserHome in   % expand `~'
	    case Sr of &/|Srr then
	       FileRest = Srr
	       UserHome = {OS.getEnv "HOME"}
	    else User in
	       FileRest = {List.takeDropWhile Sr fun {$ C} C \= &/ end ?User}
	       UserHome = {GetUserHome User}
	    end
	    case UserHome of "" then ""
	    [] _|_ then {CheckAccess {Append UserHome &/|FileRest}}
	    end
	 elsecase {CheckAccess {Append {GetDirName CurrentFileName} FileName}}
	 of S2=_|_ then S2
	 [] "" then {SearchPath {OS.getEnv "OZPATH"} FileName}
	 end
      end
   end

   %--------------------------------------------------------------------
   % String Handling

   fun {ButLast Xs}
      case Xs of X|Xr then
	 case Xr of _|_ then X|{ButLast Xr}
	 else nil
	 end
      else nil
      end
   end

   fun {Strip C S}
      case S of !C|Sr then {ButLast Sr} else S end
   end

   Hex = hex(&0: 0x0 &1: 0x1 &2: 0x2 &3: 0x3 &4: 0x4
	     &5: 0x5 &6: 0x6 &7: 0x7 &8: 0x8 &9: 0x9
	     &A: 0xA &B: 0xB &C: 0xC &D: 0xD &E: 0xE &F: 0xF
	     &a: 0xA &b: 0xB &c: 0xC &d: 0xD &e: 0xE &f: 0xF)

   %--------------------------------------------------------------------
   % Scanner and Parser Auxiliary Classes
   %--------------------------------------------------------------------

   class ConditionalClass from BaseObject
      attr Conds AllTrue
      meth init()
	 Conds <- nil
	 AllTrue <- true
      end
      meth pushCondition(Flag)
	 Conds <- Flag|@Conds
	 AllTrue <- case Flag then @AllTrue else false end
      end
      meth popCondition()
	 Conds <- @Conds.2
	 case @AllTrue then skip
	 else AllTrue <- {All @Conds fun {$ C} C end}
	 end
      end
      meth negateCondition() C|Cs = @Conds in
	 Conds <- {Not C}|Cs
	 case C then AllTrue <- false
	 else AllTrue <- {All @Conds fun {$ C} C end}
	 end
      end
      meth testCondition($)
	 @AllTrue
      end
      meth currentlyConditional($)
	 @Conds \= nil
      end
   end

   class MacroClass from BaseObject
      attr Dict
      meth init()
	 Dict <- {NewDictionary}
      end
      meth define(V)
	 {Dictionary.put @Dict V true}
      end
      meth undefine(V)
	 {Dictionary.remove @Dict V}
      end
      meth isDefined(V $)
	 {Dictionary.member @Dict V}
      end
   end

   proc {EnterVersions Cs Macros Hd Tl}
      case Cs of C1|Cr then
	 case C1 of &_ then NewTl in
	    Tl = nil
	    {Macros define({String.toAtom Hd})}
	    {EnterVersions Cr Macros {Append Hd C1|NewTl} NewTl}
	 else NewTl in
	    Tl = C1|NewTl
	    {EnterVersions Cr Macros Hd NewTl}
	 end
      else
	 Tl = nil
	 {Macros define({String.toAtom Hd})}
      end
   end
in
   %--------------------------------------------------------------------
   % The Scanner
   %--------------------------------------------------------------------

   \gumpscannerprefix zz

   scanner OzScanner from GumpScanner
      attr
	 ErrorFlag ErrorCoord
	 Conditionals Macros
	 ShowInsertSwitch
	 BufferStack
	 filename line col
	 savedFilename savedLine savedCol
	 CommentLastMode CommentCoord CommentDepth
	 NewLineNumber LineErrorFlag
      feat GumpSyntax: false

      meth init(ShowInsert GumpIsActive) VersionString X in
	 GumpScanner, init()
	 ErrorFlag <- false
	 Conditionals <- {New ConditionalClass init()}
	 VersionString = &O|&z|&_|
			 {Map {Atom.toString OZVERSION}
			  fun {$ C} case C == &. then &_ else C end end}
	 Macros <- {New MacroClass init()}
	 {EnterVersions VersionString @Macros X X}
	 ShowInsertSwitch <- ShowInsert
	 self.GumpSyntax = GumpIsActive
	 BufferStack <- nil
	 filename <- ''
	 line <- 1
	 col <- 0
      end

      meth putToken1(T)
	 case {@Conditionals testCondition($)} then
	    GumpScanner, putToken1(T)
	 else skip
	 end
      end
      meth putToken(T V)
	 case {@Conditionals testCondition($)} then
	    GumpScanner, putToken(T V)
	 else skip
	 end
      end

      %--------------------------------------------------------------------
      % Handle Coordinate Information and Multiple Buffers

      meth PushBuffer(FileName)
	 try
	    GumpScanner, scanFile(FileName)
	    BufferStack <- (@filename#@line#@col#@Conditionals)|@BufferStack
	    filename <- {String.toAtom FileName}
	    line <- 1
	    col <- 0
	    Conditionals <- {New ConditionalClass init()}
	 catch gump(fileNotFound _) then C in
	    OzScanner, getCoordinates(?C)
	    {self reportError(C 'macro directive error'
			      ['could not open file to insert'])}
	 end
      end
      meth PopBuffer()
	 case {@Conditionals currentlyConditional($)} then C in
	    OzScanner, getCoordinates(?C)
	    {self reportError(C 'macro directive error'
			      ['unterminated \\ifdef of \\ifndef'])}
	 else skip
	 end
	 ErrorFlag <- false
	 GumpScanner, closeBuffer()
	 case @BufferStack of (F#L#C#Cond)|BufferStackRest then
	    BufferStack <- BufferStackRest
	    filename <- F
	    line <- L
	    col <- C
	    Conditionals <- Cond
	    GumpScanner, setMode(DIRECTIVE)
	 [] nil then
	    GumpScanner, putToken1('EOF')
	 end
      end

      %-----------------------------------------------------------------

      meth getCoordinates($)
	 pos(@filename @line @col)
      end
      meth SaveCoordinates()
	 % This has to be called each time a token of one of the following
	 % classes is produced:
	 %   'ATOM' 'ATOM()' 'VARIABLE' 'VARIABLE()' 'STRING' 'INT' 'FLOAT'
	 %   'Compare' 'FdCompare' 'FdIn' 'Add' 'FdMul' 'OtherMul'
	 savedFilename <- @filename
	 savedLine <- @line
	 savedCol <- @col
      end
      meth getSavedCoordinates($)
	 pos(@savedFilename @savedLine @savedCol)
      end
      meth UpdateCoordinates(S)
	 case S of C|Sr then
	    case C of &\n then
	       line <- @line + 1
	       col <- 0
	    else
	       col <- @col + 1
	    end
	    OzScanner, UpdateCoordinates(Sr)
	 [] nil then skip
	 end
      end

      meth ConvertPseudoChars(S Col $)
	 case S of &\\|C1|Cr then
	    case C1 of &a then &\a|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &b then &\b|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &f then &\f|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &n then &\n|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &r then &\r|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &t then &\t|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &v then &\v|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &x then C2|C3|Crr = Cr C in
	       C = Hex.C2 * 16 + Hex.C3
	       case C == 0 then
		  case {@Conditionals testCondition($)} then
		     {self reportError(pos(@filename @line Col) 'lexical error'
				       ['character in hexadecimal notation == 0'])}
		  else skip
		  end
		  (OzScanner, ConvertPseudoChars(Crr Col + 4 $))
	       else
		  C|(OzScanner, ConvertPseudoChars(Crr Col + 4 $))
	       end
	    [] &\\ then &\\|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &` then &`|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &" then &"|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    [] &' then &'|(OzScanner, ConvertPseudoChars(Cr Col + 2 $))
	    else C2|C3|Crr = Cr C in   % must be an octal constant
	       C = Hex.C1 * 64 + Hex.C2 * 8 + Hex.C3
	       case C == 0 then
		  case {@Conditionals testCondition($)} then
		     {self reportError(pos(@filename @line Col) 'lexical error'
				       ['character in octal notation == 0'])}
		  else skip
		  end
		  (OzScanner, ConvertPseudoChars(Crr Col + 4 $))
	       elsecase C >= 256 then
		  case {@Conditionals testCondition($)} then
		     {self reportError(pos(@filename @line Col) 'lexical error'
				       ['character in octal notation >= 256'])}
		  else skip
		  end
		  (C - 256)|(OzScanner, ConvertPseudoChars(Crr Col + 4 $))
	       else
		  C|(OzScanner, ConvertPseudoChars(Crr Col + 4 $))
	       end
	    end
	 elseof C|Cr then
	    C|(OzScanner, ConvertPseudoChars(Cr Col + 1 $))
	 else ""
	 end
      end

      %-----------------------------------------------------------------
      % Comments
      %-----------------------------------------------------------------

      lex <"%".*\n> line <- @line + 1 col <- 0 end

      lex <"/*">
	 CommentDepth <- 1
	 CommentCoord <- OzScanner, getCoordinates($)
	 CommentLastMode <- GumpScanner, currentMode($)
	 col <- @col + 2
	 GumpScanner, setMode(COMMENT)
      end
      mode COMMENT
	 lex <"/*">
	    CommentDepth <- @CommentDepth + 1
	    col <- @col + 2
	 end
	 lex <"*/">
	    CommentDepth <- @CommentDepth - 1
	    case @CommentDepth == 0 then
	       GumpScanner, setMode(@CommentLastMode)
	    else skip
	    end
	    col <- @col + 2
	 end
	 lex <[^*/\n]+> col <- @col + GumpScanner, getLength($) end
	 lex <\n> line <- @line + 1 col <- 0 end
	 lex <[*/]> col <- @col + 1 end
	 lex <<EOF>>
	    case {@Conditionals testCondition($)} then
	       {self reportError(@CommentCoord 'lexical error'
				 ['unterminated comment'])}
	    else skip
	    end
	    OzScanner, PopBuffer()
	 end
      end

      %-----------------------------------------------------------------
      % General definitions

      lex blank = <[ \r\t]> end
      lex filename = <[A-Za-z0-9/_~.-]+|\'[ -~]+\'> end

      lex space = <[?\t\n\v\f\r ]> end
      lex spacenonl = <[?\t\v\f\r ]> end
      lex lower = <[a-z\337-\366\370-\377]> end
      lex upper = <[A-Z\300-\326\330-\336]> end
      lex digit = <[0-9]> end
      lex nonzerodigit = <[1-9]> end
      lex alphaNum = <{lower}|{upper}|{digit}|_> end
      lex char = <[^\\\x00]> end
      lex variableChar = <[^`\\\x00]> end
      lex atomChar = <[^'\\\x00]> end
      lex stringChar = <[^\"\\\x00]> end
      lex escape = <[abfnrtv\\'\"`]> end
      lex bin = <[0-1]> end
      lex oct = <[0-7]> end
      lex hex = <[0-9a-fA-F]> end
      lex pseudoChar = <\\({oct}{3}|[xX]{hex}{2}|{escape})> end
      lex anyChar = <{char}|{pseudoChar}> end

      %-----------------------------------------------------------------
      % Compiler Directives
      %-----------------------------------------------------------------

      lex <\\he(lp?)?>
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('help')
	 GumpScanner, setMode(DIRECTIVE)
      end

      lex <\\l(i(ne?)?)?>
	 col <- @col + GumpScanner, getLength($)
	 case {@Conditionals testCondition($)} then
	    NewLineNumber <- ~1   % meaning: expecting line number first
	    LineErrorFlag <- false
	    ErrorFlag <- true
	    GumpScanner, setMode(LINE)
	 else skip
	 end
      end
      mode LINE from DIRECTIVEWITHARGS
	 lex <[0-9]+>
	    col <- @col + GumpScanner, getLength($)
	    case @NewLineNumber == ~1 then
	       NewLineNumber <- {String.toInt GumpScanner, getString($)}
	    else
	       LineErrorFlag <- true
	       ErrorCoord <- OzScanner, getCoordinates($)
	    end
	 end
	 lex <{filename}>
	    col <- @col + GumpScanner, getLength($)
	    case @NewLineNumber == ~1 then
	       ErrorFlag <- true
	       ErrorCoord <- OzScanner, getCoordinates($)
	    else Stripped FileName in
	       line <- @NewLineNumber
	       Stripped = {Strip &' GumpScanner, getString($)}
	       FileName = {ExpandFileName Stripped {Atom.toString @filename}}
	       case FileName of "" then
		  filename <- {String.toAtom Stripped}
	       else
		  filename <- {String.toAtom FileName}
	       end
	       ErrorFlag <- @LineErrorFlag
	    end
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\s(w(i(t(ch?)?)?)?)?>
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('switch')
	 GumpScanner, setMode(SWITCH)
      end
      mode SWITCH from DIRECTIVE
	 lex <"+">
	    col <- @col + 1
	    OzScanner, putToken1('+')
	 end
	 lex <"-">
	    col <- @col + 1
	    OzScanner, putToken1('-')
	 end
	 lex <{alphaNum}+>
	    col <- @col + GumpScanner, getLength($)
	    OzScanner, putToken('SWITCHNAME' GumpScanner, getAtom($))
	 end
      end

      lex <\\sh(o(w(Switches)?)?)?>
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('showSwitches')
	 GumpScanner, setMode(DIRECTIVE)
      end
      lex <\\pu(s(h(Switches)?)?)?>
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('pushSwitches')
	 GumpScanner, setMode(DIRECTIVE)
      end
      lex <\\po(p(Switches)?)?>
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('popSwitches')
	 GumpScanner, setMode(DIRECTIVE)
      end

      lex <\\f(e(ed?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('feed')
	 GumpScanner, setMode(INPUTFILE)
      end
      lex <\\threadedfeed>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('threadedfeed')
	 GumpScanner, setMode(INPUTFILE)
      end
      lex <\\c(o(re?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('core')
	 GumpScanner, setMode(INPUTFILE)
      end
      lex <\\m(a(c(h(i(ne?)?)?)?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken1('machine')
	 GumpScanner, setMode(INPUTFILE)
      end
      mode INPUTFILE from DIRECTIVEWITHARGS
	 lex <{filename}> Stripped FileName in
	    col <- @col + GumpScanner, getLength($)
	    Stripped = {Strip &' GumpScanner, getString($)}
	    FileName = {ExpandFileName Stripped {Atom.toString @filename}}
	    case FileName of "" then
	       OzScanner, putToken('FILENAME' {String.toAtom Stripped})
	    else
	       OzScanner, putToken('FILENAME' {String.toAtom FileName})
	    end
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\in(s(e(rt?)?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(INSERT)
      end
      mode INSERT from DIRECTIVEWITHARGS
	 lex <{filename}>
	    col <- @col + GumpScanner, getLength($)
	    case {@Conditionals testCondition($)} then Stripped FileName in
	       Stripped = {Strip &' GumpScanner, getString($)}
	       FileName = {ExpandFileName Stripped {Atom.toString @filename}}
	       case FileName of "" then C in
		  OzScanner, getCoordinates(?C)
		  {self reportError(C 'macro directive error'
				    ['could not open file to insert'])}
		  GumpScanner, setMode(DIRECTIVE)
	       else
		  case @ShowInsertSwitch then
		     {System.showInfo '%%%     inserting file "'#FileName#'"'}
		  else skip
		  end
		  OzScanner, PushBuffer(FileName)
		  GumpScanner, setMode(INITIAL)
	       end
	    else
	       GumpScanner, setMode(DIRECTIVE)
	    end
	 end
      end

      lex <\\d(e(f(i(ne?)?)?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(DEFINE)
      end
      mode DEFINE from DIRECTIVEWITHARGS
	 lex <{variable}>
	    col <- @col + GumpScanner, getLength($)
	    case {@Conditionals testCondition($)} then
	       {@Macros define(GumpScanner, getAtom($))}
	    else skip
	    end
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\u(n(d(ef?)?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(UNDEF)
      end
      mode UNDEF from DIRECTIVEWITHARGS
	 lex <{variable}>
	    col <- @col + GumpScanner, getLength($)
	    case {@Conditionals testCondition($)} then
	       {@Macros undefine(GumpScanner, getAtom($))}
	    else skip
	    end
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\ifd(ef?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(IFDEF)
      end
      mode IFDEF from DIRECTIVEWITHARGS
	 lex <{variable}>
	    col <- @col + GumpScanner, getLength($)
	    {@Conditionals
	     pushCondition({@Macros isDefined(GumpScanner, getAtom($) $)})}
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\ifn(d(ef?)?)?>
	 ErrorCoord <- OzScanner, getCoordinates($)
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(IFNDEF)
      end
      mode IFNDEF from DIRECTIVEWITHARGS
	 lex <{variable}>
	    col <- @col + GumpScanner, getLength($)
	    {@Conditionals
	     pushCondition({Not {@Macros isDefined(GumpScanner, getAtom($) $)}})}
	    GumpScanner, setMode(DIRECTIVE)
	 end
      end

      lex <\\el(se?)?>
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(DIRECTIVE)
	 case {@Conditionals currentlyConditional($)} then
	    {@Conditionals negateCondition()}
	 else C in
	    OzScanner, getCoordinates(?C)
	    {self reportError(C 'macro directive error'
			      ['\\else without previous corresponding '#
			       '\\ifdef or \\ifndef'])}
	 end
      end

      lex <\\en(d(if?)?)?>
	 col <- @col + GumpScanner, getLength($)
	 GumpScanner, setMode(DIRECTIVE)
	 case {@Conditionals currentlyConditional($)} then
	    {@Conditionals popCondition()}
	 else C in
	    OzScanner, getCoordinates(?C)
	    {self reportError(C 'macro directive error'
			['\\endif without previous corresponding '#
			 '\\ifdef or \\ifndef'])}
	 end
      end

      mode DIRECTIVEWITHARGS from DIRECTIVE
	 lex <<EOF>>
	    {self reportError(OzScanner, getCoordinates($) 'directive error'
			      ['unterminated directive'])}
	    OzScanner, PopBuffer()
	 end
      end
      mode DIRECTIVE
	 % common layout rules valid for all directives
	 lex <{blank}+> col <- @col + GumpScanner, getLength($) end
	 lex <.>
	    OzScanner, UpdateCoordinates(GumpScanner, getString($))
	    case @ErrorFlag then skip
	    else
	       ErrorFlag <- true
	       ErrorCoord <- OzScanner, getCoordinates($)
	    end
	 end
	 lex <\n>
	    line <- @line + 1 col <- 0
	    case @ErrorFlag then
	       {self reportError(@ErrorCoord 'directive error'
				 ['illegal directive syntax'])}
	       ErrorFlag <- false
	    else skip
	    end
	    GumpScanner, setMode(INITIAL)
	 end
	 lex <<EOF>>
	    OzScanner, PopBuffer()
	 end
      end

      %--------------------------------------------------------------------
      % Gump Extensions
      %--------------------------------------------------------------------

      lex regexChar = <"["([^\]\\]|\\.)+"]"|\"[^"]+\"|\\.|[^<>"\[\]\\\n]> end

      lex <"=>"> col <- @col + 2 OzScanner, putToken1('=>') end
      lex <"//"> col <- @col + 2 OzScanner, putToken1('//') end

      lex <lex>
	 case self.GumpSyntax then
	    col <- @col + 3
	    OzScanner, putToken1('lex')
	    GumpScanner, setMode(LEX)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 3
	    OzScanner, putToken('ATOM' 'lex')
	 end
      end
      lex <mode>
	 case self.GumpSyntax then
	    col <- @col + 4
	    OzScanner, putToken1('mode')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 4
	    OzScanner, putToken('ATOM' 'mode')
	 end
      end
      lex <parser>
	 case self.GumpSyntax then C in
	    OzScanner, getCoordinates(?C)
	    col <- @col + 6
	    OzScanner, putToken('parser' C)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 6
	    OzScanner, putToken('ATOM' 'parser')
	 end
      end
      lex <prod>
	 case self.GumpSyntax then
	    col <- @col + 4
	    OzScanner, putToken1('prod')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 4
	    OzScanner, putToken('ATOM' 'prod')
	 end
      end
      lex <scanner>
	 case self.GumpSyntax then C in
	    OzScanner, getCoordinates(?C)
	    col <- @col + 7
	    OzScanner, putToken('scanner' C)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 7
	    OzScanner, putToken('ATOM' 'scanner')
	 end
      end
      lex <syn>
	 case self.GumpSyntax then
	    col <- @col + 3
	    OzScanner, putToken1('syn')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 3
	    OzScanner, putToken('ATOM' 'syn')
	 end
      end
      lex <token>
	 case self.GumpSyntax then
	    col <- @col + 5
	    OzScanner, putToken1('token')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 5
	    OzScanner, putToken('ATOM' 'token')
	 end
      end

      lex <lex/\(>
	 case self.GumpSyntax then
	    col <- @col + 3
	    OzScanner, putToken1('lex')
	    GumpScanner, setMode(LEX)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 3
	    OzScanner, putToken('ATOM()' 'lex')
	 end
      end
      lex <mode/\(>
	 case self.GumpSyntax then
	    col <- @col + 4
	    OzScanner, putToken1('mode')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 4
	    OzScanner, putToken('ATOM()' 'mode')
	 end
      end
      lex <parser/\(>
	 case self.GumpSyntax then C in
	    OzScanner, getCoordinates(?C)
	    col <- @col + 6
	    OzScanner, putToken('parser' C)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 6
	    OzScanner, putToken('ATOM()' 'parser')
	 end
      end
      lex <prod/\(>
	 case self.GumpSyntax then
	    col <- @col + 4
	    OzScanner, putToken1('prod')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 4
	    OzScanner, putToken('ATOM()' 'prod')
	 end
      end
      lex <scanner/\(>
	 case self.GumpSyntax then C in
	    OzScanner, getCoordinates(?C)
	    col <- @col + 7
	    OzScanner, putToken('scanner' C)
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 7
	    OzScanner, putToken('ATOM()' 'scanner')
	 end
      end
      lex <syn/\(>
	 case self.GumpSyntax then
	    col <- @col + 3
	    OzScanner, putToken1('syn')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 3
	    OzScanner, putToken('ATOM()' 'syn')
	 end
      end
      lex <token/\(>
	 case self.GumpSyntax then
	    col <- @col + 5
	    OzScanner, putToken1('token')
	 else
	    OzScanner, SaveCoordinates()
	    col <- @col + 5
	    OzScanner, putToken('ATOM()' 'token')
	 end
      end

      mode LEX from INITIAL
	 lex <"<<EOF>>">
	    col <- @col + 7
	    OzScanner, putToken('REGEX' GumpScanner, getAtom($))
	    GumpScanner, setMode(INITIAL)
	 end
	 lex <"<"{regexChar}+">"> S in
	    GumpScanner, getString(?S)
	    OzScanner, UpdateCoordinates(S)
	    OzScanner, putToken('REGEX' {String.toAtom {ButLast S.2}})
	    GumpScanner, setMode(INITIAL)
	 end
      end

      %-----------------------------------------------------------------
      % The Oz Notation
      %-----------------------------------------------------------------

      %-----------------------------------------------------------------
      % Keywords

      lex <else>        col <- @col + 4 OzScanner, putToken1('else')     end
      lex <elseof>      col <- @col + 6 OzScanner, putToken1('elseof')   end
      lex <finally>     col <- @col + 7 OzScanner, putToken1('finally')  end
      lex <in>          col <- @col + 2 OzScanner, putToken1('in')       end
      lex <of>          col <- @col + 2 OzScanner, putToken1('of')       end
      lex <then>        col <- @col + 4 OzScanner, putToken1('then')     end
      lex <with>        col <- @col + 4 OzScanner, putToken1('with')     end

      lex <else/\(>     col <- @col + 4 OzScanner, putToken1('else')     end
      lex <elseof/\(>   col <- @col + 6 OzScanner, putToken1('elseof')   end
      lex <finally/\(>  col <- @col + 7 OzScanner, putToken1('finally')  end
      lex <in/\(>       col <- @col + 2 OzScanner, putToken1('in')       end
      lex <of/\(>       col <- @col + 2 OzScanner, putToken1('of')       end
      lex <then/\(>     col <- @col + 4 OzScanner, putToken1('then')     end
      lex <with/\(>     col <- @col + 4 OzScanner, putToken1('with')     end

      lex <andthen>     C in OzScanner, getCoordinates(?C) col <- @col + 7 OzScanner, putToken('andthen' C)  end
      lex <attr>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('attr' C)     end
      lex <case>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('case' C)     end
      lex <catch>       C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('catch' C)    end
      lex <choice>      C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('choice' C)   end
      lex <class>       C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('class' C)    end
      lex <condis>      C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('condis' C)   end
      lex <declare>     C in OzScanner, getCoordinates(?C) col <- @col + 7 OzScanner, putToken('declare' C)  end
      lex <dis>         C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('dis' C)      end
      lex <elsecase>    C in OzScanner, getCoordinates(?C) col <- @col + 8 OzScanner, putToken('elsecase' C) end
      lex <elseif>      C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('elseif' C)   end
      lex <end>         C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('end' C)      end
      lex <fail>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('fail' C)     end
      lex <false>       C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('false' C)    end
      lex <feat>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('feat' C)     end
      lex <from>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('from' C)     end
      lex <fun>         C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('fun' C)      end
      lex <if>          C in OzScanner, getCoordinates(?C) col <- @col + 2 OzScanner, putToken('if' C)       end
      lex <local>       C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('local' C)    end
      lex <lock>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('lock' C)     end
      lex <meth>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('meth' C)     end
      lex <not>         C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('not' C)      end
      lex <or>          C in OzScanner, getCoordinates(?C) col <- @col + 2 OzScanner, putToken('or' C)       end
      lex <orelse>      C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('orelse' C)   end
      lex <proc>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('proc' C)     end
      lex <prop>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('prop' C)     end
      lex <raise>       C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('raise' C)    end
      lex <self>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('self' C)     end
      lex <skip>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('skip' C)     end
      lex <thread>      C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('thread' C)   end
      lex <true>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('true' C)     end
      lex <try>         C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('try' C)      end
      lex <unit>        C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('unit' C)     end

      lex <andthen/\(>  C in OzScanner, getCoordinates(?C) col <- @col + 7 OzScanner, putToken('andthen' C)  end
      lex <attr/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('attr' C)     end
      lex <catch/\(>    C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('catch' C)    end
      lex <case/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('case' C)     end
      lex <choice/\(>   C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('choice' C)   end
      lex <class/\(>    C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('class' C)    end
      lex <condis/\(>   C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('condis' C)   end
      lex <declare/\(>  C in OzScanner, getCoordinates(?C) col <- @col + 7 OzScanner, putToken('declare' C)  end
      lex <dis/\(>      C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('dis' C)      end
      lex <elsecase/\(> C in OzScanner, getCoordinates(?C) col <- @col + 8 OzScanner, putToken('elsecase' C) end
      lex <elseif/\(>   C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('elseif' C)   end
      lex <end/\(>      C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('end' C)      end
      lex <fail/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('fail' C)     end
      lex <false/\(>    C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('false()' C)  end
      lex <feat/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('feat' C)     end
      lex <from/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('from' C)     end
      lex <fun/\(>      C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('fun' C)      end
      lex <if/\(>       C in OzScanner, getCoordinates(?C) col <- @col + 2 OzScanner, putToken('if' C)       end
      lex <local/\(>    C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('local' C)    end
      lex <lock/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('lock' C)     end
      lex <meth/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('meth' C)     end
      lex <not/\(>      C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('not' C)      end
      lex <or/\(>       C in OzScanner, getCoordinates(?C) col <- @col + 2 OzScanner, putToken('or' C)       end
      lex <orelse/\(>   C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('orelse' C)   end
      lex <proc/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('proc' C)     end
      lex <prop/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('prop' C)     end
      lex <raise/\(>    C in OzScanner, getCoordinates(?C) col <- @col + 5 OzScanner, putToken('raise' C)    end
      lex <self/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('self' C)     end
      lex <skip/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('skip' C)     end
      lex <thread/\(>   C in OzScanner, getCoordinates(?C) col <- @col + 6 OzScanner, putToken('thread' C)   end
      lex <true/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('true()' C)   end
      lex <try/\(>      C in OzScanner, getCoordinates(?C) col <- @col + 3 OzScanner, putToken('try' C)      end
      lex <unit/\(>     C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('unit()' C)   end

      lex <unit/"<<">   C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('unit()' C)   end
      lex <true/"<<">   C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('true()' C)   end
      lex <false/"<<">  C in OzScanner, getCoordinates(?C) col <- @col + 4 OzScanner, putToken('false()' C)  end

      lex add = <"+"|"-"> end
      lex <{add}>
	 OzScanner, SaveCoordinates()
	 col <- @col + 1
	 OzScanner, putToken('Add' GumpScanner, getAtom($))
      end

      lex fdmul = <"*"|"/"> end
      lex <{fdmul}>
	 OzScanner, SaveCoordinates()
	 col <- @col + 1
	 OzScanner, putToken('FdMul' GumpScanner, getAtom($))
      end

      lex othermul = <div|mod> end
      lex <{othermul}>
	 OzScanner, SaveCoordinates()
	 col <- @col + 3
	 OzScanner, putToken('OtherMul' GumpScanner, getAtom($))
      end
      lex <{othermul}/(\(|"<<")>
	 OzScanner, SaveCoordinates()
	 col <- @col + 3
	 OzScanner, putToken('OtherMul' GumpScanner, getAtom($))
      end

      lex compare = <"<"|">"|"=<"|">="|"\\="> end
      lex <"=="|{compare}>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('Compare' GumpScanner, getAtom($))
      end

      lex fdin = <"::"|":::"> end
      lex <{fdin}>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('FdIn' GumpScanner, getAtom($))
      end

      lex <(=|{compare}):>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('FdCompare' GumpScanner, getAtom($))
      end

      lex <"..."> col <- @col + 3 OzScanner, putToken1('...') end
      lex <"[]">  col <- @col + 2 OzScanner, putToken1('[]')  end
      lex <"<<">  col <- @col + 2 OzScanner, putToken1('<<')  end
      lex <">>">  col <- @col + 2 OzScanner, putToken1('>>')  end

      lex <"<-"> C in
	 OzScanner, getCoordinates(?C)
	 col <- @col + 2
	 OzScanner, putToken('<-' C)
      end
      lex <"<="> C in
	 OzScanner, getCoordinates(?C)
	 col <- @col + 2
	 OzScanner, putToken('<=' C)
      end

      lex <"{"|"["|"|"|"#"|"="|"."|"^"|"@"|"$"|"!"|"~"|"_"|","> C in
	 OzScanner, getCoordinates(?C)
	 col <- @col + 1
	 OzScanner, putToken(GumpScanner, getAtom($) C)
      end
      lex <"}"|"("|")"|"]"|":">
	 col <- @col + 1
	 OzScanner, putToken1(GumpScanner, getAtom($))
      end

      %-----------------------------------------------------------------
      % Variables, atoms, labels, strings, numbers

      lex variable = <{upper}{alphaNum}*> end
      lex variableQuoted = <`({variableChar}|{pseudoChar})*`> end
      lex <{variable}>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('VARIABLE' GumpScanner, getAtom($))
      end
      lex <{variableQuoted}> S1 S2 in
	 OzScanner, SaveCoordinates()
	 GumpScanner, getString(?S1)
	 OzScanner, ConvertPseudoChars(S1 @col ?S2)
	 OzScanner, UpdateCoordinates(S1)
	 OzScanner, putToken('VARIABLE' {String.toAtom S2})
      end
      lex <{variable}/(\(|"<<")>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('VARIABLE()' GumpScanner, getAtom($))
      end
      lex <{variableQuoted}/(\(|"<<")> S1 S2 in
	 OzScanner, SaveCoordinates()
	 GumpScanner, getString(?S1)
	 OzScanner, ConvertPseudoChars(S1 @col ?S2)
	 OzScanner, UpdateCoordinates(S1)
	 OzScanner, putToken('VARIABLE()' {String.toAtom S2})
      end

      lex atom = <{lower}{alphaNum}*> end
      lex atomQuoted = <"'"({atomChar}|{pseudoChar})*"'"> end
      lex <{atom}>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('ATOM' GumpScanner, getAtom($))
      end
      lex <{atomQuoted}> S1 S2 in
	 OzScanner, SaveCoordinates()
	 GumpScanner, getString(?S1)
	 OzScanner, ConvertPseudoChars({Strip &' S1} @col ?S2)
	 OzScanner, UpdateCoordinates(S1)
	 OzScanner, putToken('ATOM' {String.toAtom S2})
      end
      lex <{atom}/(\(|"<<")>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('ATOM()' GumpScanner, getAtom($))
      end
      lex <{atomQuoted}/(\(|"<<")> S1 S2 in
	 OzScanner, SaveCoordinates()
	 GumpScanner, getString(?S1)
	 OzScanner, ConvertPseudoChars({Strip &' S1} @col ?S2)
	 OzScanner, UpdateCoordinates(S1)
	 OzScanner, putToken('ATOM()' {String.toAtom S2})
      end

      lex string = <\"({stringChar}|{pseudoChar})*\"> end
      lex <{string}> S1 S2 in
	 OzScanner, SaveCoordinates()
	 GumpScanner, getString(?S1)
	 OzScanner, ConvertPseudoChars({Strip &" S1} @col ?S2)
	 OzScanner, UpdateCoordinates(S1)
	 OzScanner, putToken('STRING' S2)
      end

      lex int = <~?(0{oct}*|0[Xx]{hex}+|0[Bb]{bin}+|{nonzerodigit}{digit}*)> end
      lex <{int}>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('INT' {String.toInt GumpScanner, getString($)})
      end
      lex <"."{space}*{digit}+> S C in
	 OzScanner, getCoordinates(C)
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 S = GumpScanner, getString($)
	 % This special case rule ensures that "X.1.1" is tokenized as
	 %   "X" "." "1" "." "1"
	 % and not as
	 %   "X" "." "1.1".
	 % Caveat: comments are not allowed between `.' and number.
	 OzScanner, putToken('.' C)
	 OzScanner, putToken('INT' {String.toInt
				    {List.dropWhile S
				     fun {$ C}
					{Not {Char.isDigit C}}
				     end}})
      end
      lex <{digit}+/\.\.\.>
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 % This special case rule ensures that "1..." is tokenized as
	 %   "1" "..."
	 % and not as
	 %   "1." "." "."
	 OzScanner, putToken('INT' {String.toInt GumpScanner, getString($)})
      end

      lex float = <~?{digit}+"."{digit}*([eE]~?{digit}+)?> end
      lex <{float}> F in
	 OzScanner, SaveCoordinates()
	 col <- @col + GumpScanner, getLength($)
	 F = {String.toFloat GumpScanner, getString($)}
	 OzScanner, putToken('FLOAT' F)
      end

      lex <"&"{anyChar}> S1 S2 in
	 OzScanner, SaveCoordinates()
	 S1 = GumpScanner, getString($)
	 OzScanner, ConvertPseudoChars(S1.2 @col ?S2)
	 col <- @col + GumpScanner, getLength($)
	 OzScanner, putToken('INT' S2.1)
      end

      lex <{spacenonl}+> col <- @col + GumpScanner, getLength($) end
      lex <\n+> line <- @line + GumpScanner, getLength($) col <- 0 end

      lex <\'[^']+\'>
	 case {@Conditionals testCondition($)} then
	    {self reportError(OzScanner, getCoordinates($) 'lexical error'
			      ['illegal quoted atom syntax'])}
	 else skip
	 end
	 OzScanner, UpdateCoordinates(GumpScanner, getString($))
	 OzScanner, putToken1('error')
      end
      lex <`[^`]*`>
	 case {@Conditionals testCondition($)} then
	    {self reportError(OzScanner, getCoordinates($) 'lexical error'
			      ['illegal backquote variable syntax'])}
	 else skip
	 end
	 OzScanner, UpdateCoordinates(GumpScanner, getString($))
	 OzScanner, putToken1('error')
      end
      lex <\"[^"]+\">
	 case {@Conditionals testCondition($)} then
	    {self reportError(OzScanner, getCoordinates($) 'lexical error'
			      ['illegal string syntax'])}
	 else skip
	 end
	 OzScanner, UpdateCoordinates(GumpScanner, getString($))
	 OzScanner, putToken1('error')
      end

      lex <.>
	 case {@Conditionals testCondition($)} then
	    {self reportError(OzScanner, getCoordinates($) 'lexical error'
			      ['illegal (pseudo-)character'])}
	 else skip
	 end
	 OzScanner, UpdateCoordinates(GumpScanner, getString($))
      end

      lex <<EOF>>
	 OzScanner, PopBuffer()
      end
   end
end
